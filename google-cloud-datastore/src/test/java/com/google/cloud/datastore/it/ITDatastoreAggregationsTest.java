/*
 * Copyright 2023 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.cloud.datastore.it;

import static com.google.cloud.datastore.aggregation.Aggregation.avg;
import static com.google.cloud.datastore.aggregation.Aggregation.count;
import static com.google.cloud.datastore.aggregation.Aggregation.sum;
import static com.google.common.collect.Iterables.getOnlyElement;
import static com.google.common.truth.Truth.assertThat;

import com.google.cloud.datastore.AggregationQuery;
import com.google.cloud.datastore.AggregationResult;
import com.google.cloud.datastore.Datastore;
import com.google.cloud.datastore.Datastore.TransactionCallable;
import com.google.cloud.datastore.Entity;
import com.google.cloud.datastore.EntityQuery;
import com.google.cloud.datastore.GqlQuery;
import com.google.cloud.datastore.Key;
import com.google.cloud.datastore.Query;
import com.google.cloud.datastore.QueryResults;
import com.google.cloud.datastore.Transaction;
import com.google.common.collect.ImmutableList;
import com.google.datastore.v1.TransactionOptions;
import com.google.datastore.v1.TransactionOptions.ReadOnly;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import org.junit.After;
import org.junit.BeforeClass;
import org.junit.ClassRule;
import org.junit.Test;

// TODO(jainsahab) Move all the aggregation related tests from ITDatastoreTest to this file
public class ITDatastoreAggregationsTest {

  @ClassRule public static MultiDbRule multiDbRule = new MultiDbRule();

  private static Datastore DATASTORE;

  private static final String KIND = "Marks";

  @BeforeClass
  public static void beforeClass() throws Exception {
    DATASTORE = multiDbRule.getDatastore();
  }

  @After
  public void tearDown() {
    EntityQuery allEntitiesQuery = Query.newEntityQueryBuilder().build();
    QueryResults<Entity> allEntities = DATASTORE.run(allEntitiesQuery);
    Key[] keysToDelete =
        ImmutableList.copyOf(allEntities).stream().map(Entity::getKey).toArray(Key[]::new);
    DATASTORE.delete(keysToDelete);
  }

  Key key1 = DATASTORE.newKeyFactory().setKind(KIND).newKey(1);
  Key key2 = DATASTORE.newKeyFactory().setKind(KIND).newKey(2);
  Key key3 = DATASTORE.newKeyFactory().setKind(KIND).newKey(3);

  Entity entity1 =
      Entity.newBuilder(key1).set("name", "Jon Stark").set("marks", 89).set("cgpa", 7.34).build();
  Entity entity2 =
      Entity.newBuilder(key2).set("name", "Arya Stark").set("marks", 95).set("cgpa", 9.27).build();
  Entity entity3 =
      Entity.newBuilder(key3).set("name", "Night king").set("marks", 55).set("cgpa", 5.16).build();

  @Test
  public void testSumAggregation() {
    DATASTORE.put(entity1, entity2);

    EntityQuery baseQuery = Query.newEntityQueryBuilder().setKind(KIND).build();
    AggregationQuery aggregationQuery =
        Query.newAggregationQueryBuilder()
            .over(baseQuery)
            .addAggregations(sum("marks").as("total_marks"))
            .build();

    // sum of 2 entities
    assertThat(getOnlyElement(DATASTORE.runAggregation(aggregationQuery)).getLong("total_marks"))
        .isEqualTo(184L);

    // sum of 3 entities
    DATASTORE.put(entity3);
    assertThat(getOnlyElement(DATASTORE.runAggregation(aggregationQuery)).getLong("total_marks"))
        .isEqualTo(239L);
  }

  @Test
  public void testSumAggregationWithAutoGeneratedAlias() {
    DATASTORE.put(entity1, entity2);

    EntityQuery baseQuery = Query.newEntityQueryBuilder().setKind(KIND).build();
    AggregationQuery aggregationQuery =
        Query.newAggregationQueryBuilder().over(baseQuery).addAggregations(sum("marks")).build();

    // sum of 2 entities
    assertThat(getOnlyElement(DATASTORE.runAggregation(aggregationQuery)).getLong("property_1"))
        .isEqualTo(184L);

    // sum of 3 entities
    DATASTORE.put(entity3);
    assertThat(getOnlyElement(DATASTORE.runAggregation(aggregationQuery)).getLong("property_1"))
        .isEqualTo(239L);
  }

  @Test
  public void testSumAggregationInGqlQuery() {
    DATASTORE.put(entity1, entity2);

    GqlQuery<?> gqlQuery =
        GqlQuery.newGqlQueryBuilder(
                "AGGREGATE SUM(marks) AS total_marks OVER (SELECT * FROM Marks)")
            .build();

    AggregationQuery aggregationQuery = Query.newAggregationQueryBuilder().over(gqlQuery).build();

    // sum of 2 entities
    assertThat(getOnlyElement(DATASTORE.runAggregation(aggregationQuery)).getLong("total_marks"))
        .isEqualTo(184L);

    // sum of 3 entities
    DATASTORE.put(entity3);
    assertThat(getOnlyElement(DATASTORE.runAggregation(aggregationQuery)).getLong("total_marks"))
        .isEqualTo(239L);
  }

  @Test
  public void testSumAggregationWithResultOfDoubleType() {
    DATASTORE.put(entity1, entity2);

    EntityQuery baseQuery = Query.newEntityQueryBuilder().setKind(KIND).build();
    AggregationQuery aggregationQuery =
        Query.newAggregationQueryBuilder()
            .over(baseQuery)
            .addAggregations(sum("cgpa").as("total_cgpa"))
            .build();

    // sum of 2 entities
    assertThat(getOnlyElement(DATASTORE.runAggregation(aggregationQuery)).getDouble("total_cgpa"))
        .isEqualTo(16.61);

    // sum of 3 entities
    DATASTORE.put(entity3);
    assertThat(getOnlyElement(DATASTORE.runAggregation(aggregationQuery)).getDouble("total_cgpa"))
        .isEqualTo(21.77);
  }

  @Test
  public void testAvgAggregation() {
    DATASTORE.put(entity1, entity2);

    EntityQuery baseQuery = Query.newEntityQueryBuilder().setKind(KIND).build();
    AggregationQuery aggregationQuery =
        Query.newAggregationQueryBuilder()
            .over(baseQuery)
            .addAggregations(avg("marks").as("avg_marks"))
            .build();

    // avg of 2 entities
    assertThat(getOnlyElement(DATASTORE.runAggregation(aggregationQuery)).getDouble("avg_marks"))
        .isEqualTo(92D);

    // avg of 3 entities
    DATASTORE.put(entity3);
    assertThat(getOnlyElement(DATASTORE.runAggregation(aggregationQuery)).getDouble("avg_marks"))
        .isEqualTo(79.66666666666667);
  }

  @Test
  public void testAvgAggregationWithAutoGeneratedAlias() {
    DATASTORE.put(entity1, entity2);

    EntityQuery baseQuery = Query.newEntityQueryBuilder().setKind(KIND).build();
    AggregationQuery aggregationQuery =
        Query.newAggregationQueryBuilder().over(baseQuery).addAggregations(avg("marks")).build();

    // avg of 2 entities
    assertThat(getOnlyElement(DATASTORE.runAggregation(aggregationQuery)).getDouble("property_1"))
        .isEqualTo(92D);

    // avg of 3 entities
    DATASTORE.put(entity3);
    assertThat(getOnlyElement(DATASTORE.runAggregation(aggregationQuery)).getDouble("property_1"))
        .isEqualTo(79.66666666666667);
  }

  @Test
  public void testAvgAggregationInGqlQuery() {
    DATASTORE.put(entity1, entity2);

    GqlQuery<?> gqlQuery =
        Query.newGqlQueryBuilder("AGGREGATE AVG(marks) AS avg_marks OVER (SELECT * FROM Marks)")
            .build();

    AggregationQuery aggregationQuery = Query.newAggregationQueryBuilder().over(gqlQuery).build();

    // avg of 2 entities
    assertThat(getOnlyElement(DATASTORE.runAggregation(aggregationQuery)).getDouble("avg_marks"))
        .isEqualTo(92D);

    // avg of 3 entities
    DATASTORE.put(entity3);
    assertThat(getOnlyElement(DATASTORE.runAggregation(aggregationQuery)).getDouble("avg_marks"))
        .isEqualTo(79.66666666666667);
  }

  @Test
  public void testSumAndAvgAggregationTogether() {
    DATASTORE.put(entity1, entity2);

    EntityQuery baseQuery = Query.newEntityQueryBuilder().setKind(KIND).build();
    AggregationQuery aggregationQuery =
        Query.newAggregationQueryBuilder()
            .over(baseQuery)
            .addAggregations(sum("marks").as("total_marks"))
            .addAggregations(avg("marks").as("avg_marks"))
            .build();

    // sum of 2 entities
    assertThat(getOnlyElement(DATASTORE.runAggregation(aggregationQuery)).getLong("total_marks"))
        .isEqualTo(184L);
    // avg of 2 entities
    assertThat(getOnlyElement(DATASTORE.runAggregation(aggregationQuery)).getDouble("avg_marks"))
        .isEqualTo(92D);
  }

  @Test
  public void testTransactionShouldReturnAConsistentSnapshot() {
    DATASTORE.put(entity1, entity2);

    EntityQuery baseQuery = Query.newEntityQueryBuilder().setKind(KIND).build();
    AggregationQuery aggregationQuery =
        Query.newAggregationQueryBuilder()
            .over(baseQuery)
            .addAggregation(count().as("count"))
            .addAggregations(sum("marks").as("total_marks"))
            .addAggregations(avg("marks").as("avg_marks"))
            .build();

    // original entity count is 2
    assertThat(getOnlyElement(DATASTORE.runAggregation(aggregationQuery)).getLong("count"))
        .isEqualTo(2L);

    // FIRST TRANSACTION
    DATASTORE.runInTransaction(
        (TransactionCallable<Void>)
            inFirstTransaction -> {
              // creating a new entity
              inFirstTransaction.put(entity3);

              // aggregation result consistently being produced for original 2 entities
              AggregationResult aggregationResult =
                  getOnlyElement(inFirstTransaction.runAggregation(aggregationQuery));
              assertThat(aggregationResult.getLong("count")).isEqualTo(2L);
              assertThat(aggregationResult.getLong("total_marks")).isEqualTo(184L);
              assertThat(aggregationResult.getDouble("avg_marks")).isEqualTo(92D);
              return null;
            });

    // after first transaction is committed, we have 3 entities now.
    assertThat(getOnlyElement(DATASTORE.runAggregation(aggregationQuery)).getLong("count"))
        .isEqualTo(3L);

    // SECOND TRANSACTION
    DATASTORE.runInTransaction(
        (TransactionCallable<Void>)
            inSecondTransaction -> {
              // deleting ENTITY3
              inSecondTransaction.delete(entity3.getKey());

              // aggregation result still coming for 3 entities
              AggregationResult aggregationResult =
                  getOnlyElement(inSecondTransaction.runAggregation(aggregationQuery));
              assertThat(aggregationResult.getLong("count")).isEqualTo(3L);
              assertThat(aggregationResult.getLong("total_marks")).isEqualTo(239L);
              assertThat(aggregationResult.getDouble("avg_marks")).isEqualTo(79.66666666666667);
              return null;
            });

    // after second transaction is committed, we are back to 2 entities now.
    assertThat(getOnlyElement(DATASTORE.runAggregation(aggregationQuery)).getLong("count"))
        .isEqualTo(2L);
  }

  @Test
  public void testReadOnlyTransactionShouldNotLockTheDocuments()
      throws ExecutionException, InterruptedException {
    ExecutorService executor = Executors.newSingleThreadExecutor();
    DATASTORE.put(entity1, entity2);

    EntityQuery baseQuery = Query.newEntityQueryBuilder().setKind(KIND).build();
    AggregationQuery aggregationQuery =
        Query.newAggregationQueryBuilder()
            .over(baseQuery)
            .addAggregation(count().as("count"))
            .addAggregations(sum("marks").as("total_marks"))
            .addAggregations(avg("marks").as("avg_marks"))
            .build();

    TransactionOptions transactionOptions =
        TransactionOptions.newBuilder().setReadOnly(ReadOnly.newBuilder().build()).build();
    Transaction readOnlyTransaction = DATASTORE.newTransaction(transactionOptions);

    // Executing query in transaction, results for original 2 entities
    AggregationResult aggregationResult =
        getOnlyElement(readOnlyTransaction.runAggregation(aggregationQuery));
    assertThat(aggregationResult.getLong("count")).isEqualTo(2L);
    assertThat(aggregationResult.getLong("total_marks")).isEqualTo(184L);
    assertThat(aggregationResult.getDouble("avg_marks")).isEqualTo(92D);

    // Concurrent write task.
    Future<Void> addNewEntityTaskOutsideTransaction =
        executor.submit(
            () -> {
              DATASTORE.put(entity3);
              return null;
            });

    // should not throw exception and complete successfully as the ongoing transaction is read-only.
    addNewEntityTaskOutsideTransaction.get();

    // cleanup
    readOnlyTransaction.commit();
    executor.shutdownNow();

    assertThat(getOnlyElement(DATASTORE.runAggregation(aggregationQuery)).getLong("count"))
        .isEqualTo(3L);
  }
}
